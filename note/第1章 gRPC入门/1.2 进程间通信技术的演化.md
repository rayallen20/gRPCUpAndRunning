# 第1章 gPRC入门

## 1.2 进程间通信技术的演化

### 1.2.1 传统的RPC

借助RPC,客户端能够像调用本地方法那样远程调用某个方法的功能.早期有一些很流行的RPC实现,比如**通用对象请求代理体系结构**(common object request broker architecture, CORBA)和Java**远程方法调用**(remote method invocation,RMI),它们都用来构建和连接服务或应用程序.但是,大多数传统的RPC实现极其复杂,**因为它们构建在TCP这样的通信协议之上**,而这会妨碍互操作性,并且它们还有大量的规范限制.

### 1.2.2 SOAP

SOAP:simple object access protocol,简单对象访问协议

SOAP是**面向服务的架构**(service-oriented architecture, SOA)中的标准通信技术,用于在服务(在SOA中通常叫作Web服务)之间交换基于XML的结构化数据,并且能够基于任意的底层通信协议进行通信,其中最常用的协议是HTTP.

SOAP曾是一项非常流行的技术,但其消息格式的复杂性以及围绕SOAP所构建的各种规范的复杂性,妨碍了构建分布式应用程序的敏捷性.因此,在现代分布式应用程序开发中,SOAP Web服务被认为是一种遗留技术.大多数现有的分布式应用程序采用REST架构风格,而非SOAP.

### 1.2.3 REST

REST:representational state transfer,描述性状态迁移

REST是**面向资源的架构**(resource-oriented architecture,ROA)的基础,在这种架构中,需要将分布式应用程序建模为资源集合,访问这些资源的客户端可以变更这些资源的状态(创建、读取、更新或删除).

REST的通用实现是HTTP,通过HTTP,可以将RESTful Web应用程序建模为**能够通过唯一标识符访问的资源集合**.应用于资源的状态变更操作会采用HTTP动词(GET、POST、PUT、DELETE、PATCH等)的形式,资源的状态会以文本的格式来表述,如 JSON、XML、HTML、YAML等.

实际上,通过HTTP和JSON将应用程序构建为REST架构风格已成为构建微服务的标准方法.但是,随着微服务的数量及其网络交互的激增,RESTful服务已经无法满足现代化的需求了.下面介绍RESTful服务的3个主要局限性,这些局限性妨碍了其作为消息协议在现代微服务应用程序中的运用.

#### a. 基于文本的低效消息协议

从本质上来讲,RESTful服务建立在基于文本的传输协议(如HTTP 1.x)之上,并且会使用人类可读的文本格式,如 JSON.但是,在进行服务与服务之间的通信时,**通信双方都不需要这种人类可读的文本化格式**,这时使用这种格式非常低效.

客户端应用程序(源)生成需要发送给服务器的二进制内容,然后需要将二进制结构转换成文本(如果使用HTTP 1.x,就只能发送文本化消息),并通过网络以文本的形式(借助HTTP)发送到另一台机器上,这台机器需要在服务器端(目标)解析文本并将其转换回二进制结构.其实,我们也可以很轻松地发送映射服务和消费者业务逻辑的二进制内容,采用JSON格式主要是因为它是"人类可读的",相对来说易于使用.这涉及工具选择问题,而不是二进制协议问题.

#### b. 应用程序之间缺乏强类型接口

随着越来越多的服务要通过网络进行交互,而且这些服务使用完全不同的语言来构建,缺乏明确定义和强类型的服务接口成了使用RESTful服务的主要阻碍.RESTful中现有的各种服务定义技术(如OpenAPI/Swagger等)都是事后的补救措施,并没有与底层的架构风格或消息协议紧密集成在一起.

在构建这种分散的应用程序时,会遇到很多的不兼容、运行时错误和互操作等问题.例如,在开发RESTful服务时,应用程序之间并不需要共享服务定义和类型定义的信息.但是,在开发RESTful应用程序时,我们要么通过网络查看文本格式,要么使用第三方API定义技术(如OpenAPI/Swagger等).因此,现在非常重要的任务就是拥有现代化的**强类型服务定义技术以及框架**,从而为多语言技术生成核心的服务器端代码和客户端代码.

#### c. REST架构风格难以强制实施

REST架构风格有很多"好的实践",只有遵循这些实践,才能构建出真正的RESTful服务.但是,由于它们并没有作为实现协议(比如HTTP)的一部分进行强制的要求,因此在实现阶段,这些实践很难实施.事实上,大多数自称RESTful的服务并没有遵循基础的REST架构风格,也就是说,**这些所谓的RESTful服务不过是通过网络公开的HTTP服务**.因此,开发团队必须花费大量时间来维护RESTful服务的一致性和纯度.

### 1.2.4 gRPC的起源

2015年,谷歌发布了开源RPC框架gRPC,这个RPC基础设施具有标准化、可通用和跨平台的特点,旨在提供类似Stubby的可扩展性、性能和功能,但它主要面向社区.

### 1.2.5 选择gRPC的原因

#### 1.2.5.1 gRPC的优势

##### a. 提供高效的进程间通信

gRPC没有使用JSON或XML这样的文本化格式,而是使用
一个基于protocol buffers的**二进制协议**与gRPC服务和客户端通信.同时,gRPC在HTTP/2之上实现了protocol buffers,从而能够更快地处理进程间通信.这样一来,gRPC就变成了最高效的进程间通信技术之一.

##### b. 具有简单且定义良好的服务接口和模式

gRPC为应用程序开发提供了一种**契约优先**的方式.也就是说,**首先必须定义服务接口,然后才能去处理实现细节**.因此,与RESTful服务定义中的OpenAPI/Swagger和SOAP Web服务中的WSDL不同,gRPC提供了简单但一致、可靠且可扩展的应用程序开发体验.

##### c. 属于强类型

因为使用protocol buffers来定义gRPC服务,所以gRPC服务契约清晰定义了应用程序间进行通信所使用的类型.这样一来,在构建跨多个团队和技术类型的云原生应用程序时,对于其所产生的大多数运行时错误和互操作错误,可以通过静态类型来克服,因此分布式应用程序的开发更加稳定.

##### d. 支持多语言

gRPC支持多种编程语言.基于protocol buffers的服务定义是**语言中立**的.因此,我们可以选择任意一种语言,它们都能与现有的gRPC服务或客户端进行互操作

##### e. 支持双工流

gRPC在客户端和服务器端都提供了对流的原生支持,这些功能都被整合到了服务定义本身之中.因此,开发流服务或流客户端变得非常容易.与传统的RESTful服务消息风格相比,gRPC的关键优势就是能够同时构建传统的请求–响应风格的消息以及客户端流和服务器端流.

##### f. 具备内置的商业化特性

gRPC提供了对商业化特性的内置支持,如认证、加密、弹性(截止时间和超时)、元数据交换、压缩、负载均衡、服务发现等(第5章会讨论这些功能).

##### g. 与云原生生态系统进行了集成

gRPC是CNCF的一部分,大多数现代框架和技术对gRPC提供了原生支持.例如,CNCF下的很多项目(如Envoy)支持使用gRPC作为通信协议.另外,对于横切性的特性,比如度量指标和监控,gRPC也得到了大多数工具的支持,比如使用Prometheus来监控gRPC应用程序

##### h. 业已成熟并被广泛采用

通过在谷歌进行的大量实战测试,gRPC已发展成熟.许多大型科技公司采用了gRPC,如Square、Lyft、Netflix、Docker、CoreOS和思科等.

#### 1.2.5.2 gRPC的劣势

##### a. gRPC可能不太适合面向外部的服务

大多数的外部消费者可能对gRPC、REST或HTTP等协议很陌生.因此,如果希望将应用程序或服务通过互联网暴露给外部客户端,gRPC可能不是最适合的协议.**gRPC 服务具有契约驱动、强类型的特点,这可能会限制我们向外部暴露的服务的灵活性,同时消费者的控制权会削弱很多**(这与1.2.6节讨论的GraphQL协议有所不同).按照设计,gRPC网关将是克服该问题的解决方案.第8章会对此进行详细讨论.

##### b. 巨大的服务定义变更是复杂的开发流程

在现代的服务间通信场景中,模式修改很常见.**如果出现巨大的gRPC服务定义变更,通常需要重新生成客户端代码和服务器端代码.这需要整合到现有的持续集成过程中,可能会让整个开发生命周期复杂化**.但是,大多数gRPC服务定义的变更可以在不破坏服务契约的情况下完成,而且只要不引入破坏性的变更,gRPC就可以与使用不同版本proto的客户端和服务器端进行交互.因此,大多数情况并不需要重新生成代码.

##### c. gRPC生态系统相对较小

与传统的REST或HTTP等协议相比,gRPC的生态系统依然相对较小.浏览器和移动应用程序对gRPC的支持依然处于初级阶段.

### 1.2.6 gRPC与其他协议的对比:Thrift和GraphQL

#### 1.2.6.1 Thrift

Apache Thrift(以下简称Thrift)是与gRPC类似的RPC框架,最初由Facebook开发,后来被捐赠给了Apach.它有自己的接口定义语言并提供了对多种编程语言的支持.Thrift可以在定义文件中定义数据类型和服务接口.Thrift编译器以服务定义作为输入,能够生成客户端代码和服务器端代码.Thrift的传输层为网络I/O提供了抽象,并将Thrift从系统的其他组成部分中解耦出来,这意味着Thrift可以在任意传输实现上运行,如TCP、HTTP等.

##### a. 传输方面

**相对于Thrift,gRPC的倾向性更强,它为HTTP/2提供了一流的支持**.gRPC基于HTTP/2的实现充分利用了该协议的功能,从而实现了高效率并且能够支持像流这样的消息模式.

##### b. 流方面

gRPC服务定义原生支持**双向流**(客户端和服务器端),它本身便是服务定义的一部分.

##### c. 采用情况和社区资源方面

从采用情况来看,gRPC的势头似乎更好,它已围绕CNCF项目成功构建了一个良好的生态系统.同时,gRPC的社区资源非常丰富,比如良好的文档、外部的演讲以及示例.因此,相对于Thrift,采用gRPC会更顺利一些.

##### d. 性能方面

虽然目前还没有gRPC和Thrift对比的官方结果,但一些在线资源对比了两者的性能,结果显示Thrift的数据表现更好.然而,gRPC的绝大多数发布版本经过了大量的性能测试.因此,性能问题不太可能是选择Thrift而非gRPC的决定性因素.同时,一些其他RPC框架提供了类似的功能,但不管怎样,gRPC 是目前最标准、最具交互性和采用范围最广的RPC技术,处于领先地位

#### 1.2.6.2 GraphQL

GraphQL是另一项越来越流行的进程间通信技术,该项目由Facebook发起并通过开源进行了标准化.它是一门针对API的查询语言,并且是基于既有数据满足这些查询的运行时.GraphQL为传统的客户端–服务器端通信提供了一种完全不同的方法,该方法允许客户端定义希望获得的数据、获取数据的方式以及数据格式.gRPC则有针对远程方法的特定契约,借此实现客户端和服务器端之间的通信.

GraphQL更适合面向外部的服务或API,它们被直接暴露给消费者.在这种情况下,消费者需要对来自服务器端的数据有更多的控制权.以在线零售应用程序场景为例,假设`ProductInfo`服务的消费者只需要关于商品的特定信息,而不是商品属性的完整集合,而且他们希望能有一种方法来指定想要的信息,那么我们可以借助GraphQL来建模一个服务,允许消费者使用GraphQL查询语言来查询服务并获取想要的信息.

**在GraphQL和gRPC的大多数使用场景中,GraphQL用于面向外部的服务或API,而支撑API的内部服务则使用gRPC来实现**.